#lang racket/base
(require nanopass/base racket/match racket/case "cps.rkt" "beta-reduce.rkt")
(provide partial-evaluate L1 parse-L1 unparse-L1
         json-number? json-equal? json-eq?)

(define (json-number? v)
  (or (exact-integer? v)
      (and (inexact-real? v)
           (rational? v))))
(define (json-equal? v1 v2)
  (cond ((and (hash? v1) (hash? v2))
         (and (= (hash-count v1) (hash-count v2))
              (for/and
                  ((k1 (in-hash-keys v1)))
                (and (hash-has-key? v2 k1)
                     (json-equal? (hash-ref v2 k1)
                                  (hash-ref v1 k1))))))
        ((and (list? v1) (list? v2))
         (and (= (length v1) (length v2))
              (andmap (lambda (e1 e2) (json-equal? e1 e2)) v1 v2)))
        ((and (string? v1) (string? v2))
         (string=? v1 v2))
        ((and (json-number? v1) (json-number? v2))
         (= v1 v2))
        ((and (boolean? v1) (boolean? v2))
         (eq? v1 v2))
        ((and (eq? v1 'none) (eq? v2 'none))
         #t)
        (else #f)))
(define (json-eq? v1 v2)
  (cond ((and (boolean? v1) (boolean? v2))
         (eq? v1 v2))
        ((and (eq? v1 'none) (eq? v2 'none))
         #t)
        ((and (json-number? v1) (json-number? v2))
         (eq? v1 v2))
        ((and (string? v1) (string? v2))
         (string=? v1 v2))
        (else #f)))

(define-pass partial-evaluate :
  L1 (ir) -> L1 ()
  (Expr : Expr (ir) -> Expr ()
        ((if ,[e0] ,[e1] ,[e2])
         (if (or (datum? e0) (primitive? e0) (lambda? e0))
             (if (nanopass-case (L1 Expr) e0
                                (',d d)
                                (else #t))
                 `,e1
                 `,e2)
             `(if ,e0 ,e1 ,e2)))
        ((,[e0] ,[e1] ,[e2])
         (nanopass-case (L1 Expr) `(,e0 ,e1 ,e2)
                        ((,pr ',d0 ',d1)
                         (match* (pr d0 d1)
                           (((and (or '+ '- '* '/ 'quotient 'modulo) op)
                             (? json-number? num1)
                             (? json-number? num2))
                            `',((case/eq op
                                         ((+) +)
                                         ((-) -)
                                         ((*) *)
                                         ((/) (lambda (v1 v2)
                                                (if (and (exact-integer? v1)
                                                         (exact-integer? v2)
                                                         (= (modulo v1 v2) 0))
                                                    (/ v1 v2)
                                                    ; JSON does not support exact rationals
                                                    (exact->inexact (/ v1 v2)))
                                                ))
                                         ((quotient) quotient)
                                         ((modulo) modulo)
                                         )
                                num1
                                num2))
                           (((and (or 'equal? 'eq?) op)
                             d0
                             d1)
                            `',((case/eq op
                                         ((equal?) json-equal?)
                                         ((eq?) json-eq?))
                                d0 d1))
                           ((op d0 d1)
                            `(,op ',d0 ',d1))))
                        (else `(,e0 ,e1 ,e2))))
        ((,[e0] ,[e1])
         (nanopass-case (L1 Expr) `(,e0 ,e1)
                        ((,pr ',d)
                         (match* (pr d)
                           (((and (or 'negate) op)
                             (? json-number? num))
                            `',((case/eq op
                                         ((negate) -))
                                num))
                           ((op d)
                            `(,op ',d))))
                        (else `(,e0 ,e1))))))
